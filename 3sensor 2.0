int val  = 0;  // Right sensor  (13)
int va2  = 0;  // Left sensor   (12)
int va3  = 0;  // Middle sensor (2) ← CHANGED

int baseSpeed  = 100;
int fastSpeed  = 180;
int turnSpeed  = 150;
int sharpSpeed = 220;

int lastTurn = 0;
unsigned long lostTime = 0;

void setup()
{
  Serial.begin(9600);

  pinMode(13, INPUT);   // Right
  pinMode(12, INPUT);   // Left
  pinMode(2,  INPUT);   // Middle ← CHANGED

  pinMode(8, OUTPUT);   // IN1
  pinMode(7, OUTPUT);   // IN2
  pinMode(9, OUTPUT);   // ENA

  pinMode(5, OUTPUT);   // IN3
  pinMode(4, OUTPUT);   // IN4
  pinMode(3, OUTPUT);   // ENB

  analogWrite(9, baseSpeed);
  analogWrite(3, baseSpeed);
}

void leftForward(int spd)  { analogWrite(9, spd); digitalWrite(8, HIGH); digitalWrite(7, LOW);  }
void leftBackward(int spd) { analogWrite(9, spd); digitalWrite(8, LOW);  digitalWrite(7, HIGH); }
void leftStop()            { analogWrite(9, 0);   digitalWrite(8, LOW);  digitalWrite(7, LOW);  }

void rightForward(int spd)  { analogWrite(3, spd); digitalWrite(5, HIGH); digitalWrite(4, LOW);  }
void rightBackward(int spd) { analogWrite(3, spd); digitalWrite(5, LOW);  digitalWrite(4, HIGH); }
void rightStop()            { analogWrite(3, 0);   digitalWrite(5, LOW);  digitalWrite(4, LOW);  }

void stopAll() { leftStop(); rightStop(); }

void loop()
{
  val = digitalRead(13);   // Right
  va2 = digitalRead(12);   // Left
  va3 = digitalRead(2);    // Middle ← CHANGED

  Serial.print("R:"); Serial.print(val);
  Serial.print(" L:"); Serial.print(va2);
  Serial.print(" M:"); Serial.println(va3);

  delay(8);

  // FAR RIGHT only = sharp right turn
  if (val == 0 && va2 == 1 && va3 == 1)
  {
    leftForward(sharpSpeed);
    rightBackward(sharpSpeed);
    lastTurn = 1;
    return;
  }

  // FAR LEFT only = sharp left turn
  if (val == 1 && va2 == 0 && va3 == 1)
  {
    leftBackward(sharpSpeed);
    rightForward(sharpSpeed);
    lastTurn = -1;
    return;
  }

  // ALL 3 ON BLACK: go straight
  if (val == 0 && va2 == 0 && va3 == 0)
  {
    leftForward(baseSpeed);
    rightForward(baseSpeed);
    lostTime = 0;
  }

  // MIDDLE + LEFT ON BLACK: veer left
  else if (val == 1 && va2 == 0 && va3 == 0)
  {
    leftBackward(fastSpeed);
    rightForward(baseSpeed);
    lastTurn = -1;
    lostTime = 0;
  }

  // MIDDLE + RIGHT ON BLACK: veer right
  else if (val == 0 && va2 == 1 && va3 == 0)
  {
    leftForward(baseSpeed);
    rightBackward(fastSpeed);
    lastTurn = 1;
    lostTime = 0;
  }

  // ONLY MIDDLE ON BLACK: go straight
  else if (val == 1 && va2 == 1 && va3 == 0)
  {
    leftForward(baseSpeed);
    rightForward(baseSpeed);
    lostTime = 0;
  }

  // LEFT + RIGHT, NO MIDDLE: intersection - go straight
  else if (val == 0 && va2 == 0 && va3 == 1)
  {
    leftForward(baseSpeed);
    rightForward(baseSpeed);
    lostTime = 0;
  }

  // ALL WHITE = LOST
  else if (val == 1 && va2 == 1 && va3 == 1)
  {
    if (lostTime == 0) lostTime = millis();

    unsigned long lost = millis() - lostTime;

    // Phase 1 (0-300ms): coast forward - dash gap
    if (lost < 300)
    {
      leftForward(baseSpeed);
      rightForward(baseSpeed);
    }

    // Phase 2 (300-900ms): sweep last turn direction
    else if (lost < 900)
    {
      if (lastTurn == 1) {
        leftForward(sharpSpeed);
        rightBackward(sharpSpeed);
      } else {
        leftBackward(sharpSpeed);
        rightForward(sharpSpeed);
      }
    }

    // Phase 3 (900-1800ms): sweep opposite direction
    else if (lost < 1800)
    {
      if (lastTurn == 1) {
        leftBackward(sharpSpeed);
        rightForward(sharpSpeed);
      } else {
        leftForward(sharpSpeed);
        rightBackward(sharpSpeed);
      }
    }

    // Phase 4 (1800ms+): nudge forward and reset
    else
    {
      leftForward(baseSpeed);
      rightForward(baseSpeed);
      delay(150);
      lostTime = 0;
    }
  }
}
