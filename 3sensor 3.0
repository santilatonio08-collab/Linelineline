int val  = 0;  // Right sensor  (13)
int va2  = 0;  // Left sensor   (12)
int va3  = 0;  // Middle sensor (11)

int baseSpeed = 100;
int fastSpeed = 180;
int turnSpeed = 150;

// ── ADDED: lost line tracking ─────────────────────────
unsigned long lostTime = 0;
int lastTurn = 0;  // -1 = left, 1 = right

void setup()
{
  Serial.begin(9600);

  pinMode(13, INPUT);   // Right
  pinMode(12, INPUT);   // Left
  pinMode(11, INPUT);   // Middle

  pinMode(8, OUTPUT);   // IN1
  pinMode(7, OUTPUT);   // IN2
  pinMode(9, OUTPUT);   // ENA

  pinMode(5, OUTPUT);   // IN3
  pinMode(4, OUTPUT);   // IN4
  pinMode(3, OUTPUT);   // ENB

  analogWrite(9, baseSpeed);
  analogWrite(3, baseSpeed);
}

void loop()
{
  val = digitalRead(13);   // Right
  va2 = digitalRead(12);   // Left
  va3 = digitalRead(11);   // Middle

  Serial.print("R(13):"); Serial.print(val);
  Serial.print(" L(12):"); Serial.print(va2);
  Serial.print(" M(11):"); Serial.println(va3);

  delay(8);

  // ── ALL 3 ON BLACK: go straight ──────────────────────
  if (val == 0 && va2 == 0 && va3 == 0)
  {
    lostTime = 0;  // ← ADDED: reset lost timer
    analogWrite(9, baseSpeed);
    analogWrite(3, baseSpeed);
    digitalWrite(8, HIGH); digitalWrite(7, LOW);
    digitalWrite(5, HIGH); digitalWrite(4, LOW);
  }

  // ── MIDDLE + LEFT ON BLACK: veer left ────────────────
  else if (val == 1 && va2 == 0 && va3 == 0)
  {
    lostTime = 0;  // ← ADDED
    lastTurn = -1; // ← ADDED
    analogWrite(9, fastSpeed);
    analogWrite(3, baseSpeed);
    digitalWrite(8, LOW);  digitalWrite(7, HIGH);
    digitalWrite(5, HIGH); digitalWrite(4, LOW);
  }

  // ── MIDDLE + RIGHT ON BLACK: veer right ──────────────
  else if (val == 0 && va2 == 1 && va3 == 0)
  {
    lostTime = 0;  // ← ADDED
    lastTurn = 1;  // ← ADDED
    analogWrite(9, baseSpeed);
    analogWrite(3, fastSpeed);
    digitalWrite(8, HIGH); digitalWrite(7, LOW);
    digitalWrite(5, LOW);  digitalWrite(4, HIGH);
  }

  // ── ONLY MIDDLE ON BLACK: go straight ────────────────
  else if (val == 1 && va2 == 1 && va3 == 0)
  {
    lostTime = 0;  // ← ADDED
    analogWrite(9, baseSpeed);
    analogWrite(3, baseSpeed);
    digitalWrite(8, HIGH); digitalWrite(7, LOW);
    digitalWrite(5, HIGH); digitalWrite(4, LOW);
  }

  // ── ONLY RIGHT ON BLACK: turn right ──────────────────
  else if (val == 0 && va2 == 1 && va3 == 1)
  {
    lostTime = 0;  // ← ADDED
    lastTurn = 1;  // ← ADDED
    analogWrite(9, baseSpeed);
    analogWrite(3, fastSpeed);
    digitalWrite(8, HIGH); digitalWrite(7, LOW);
    digitalWrite(5, LOW);  digitalWrite(4, HIGH);
  }

  // ── ONLY LEFT ON BLACK: turn left ────────────────────
  else if (val == 1 && va2 == 0 && va3 == 1)
  {
    lostTime = 0;  // ← ADDED
    lastTurn = -1; // ← ADDED
    analogWrite(9, fastSpeed);
    analogWrite(3, baseSpeed);
    digitalWrite(8, LOW);  digitalWrite(7, HIGH);
    digitalWrite(5, HIGH); digitalWrite(4, LOW);
  }

  // ── LEFT + RIGHT ON BLACK (no middle): intersection ──
  else if (val == 0 && va2 == 0 && va3 == 1)
  {
    lostTime = 0;  // ← ADDED
    analogWrite(9, baseSpeed);
    analogWrite(3, baseSpeed);
    digitalWrite(8, HIGH); digitalWrite(7, LOW);
    digitalWrite(5, HIGH); digitalWrite(4, LOW);
  }

  // ── ALL WHITE: lost ───────────────────────────────────
  // ← REPLACED entire block with phased recovery
  else if (val == 1 && va2 == 1 && va3 == 1)
  {
    if (lostTime == 0) lostTime = millis();
    unsigned long lost = millis() - lostTime;

    // Phase 1 (0-300ms): coast forward - might be a dash gap
    if (lost < 300)
    {
      analogWrite(9, baseSpeed);
      analogWrite(3, baseSpeed);
      digitalWrite(8, HIGH); digitalWrite(7, LOW);
      digitalWrite(5, HIGH); digitalWrite(4, LOW);
    }

    // Phase 2 (300-900ms): spin toward last known turn
    else if (lost < 900)
    {
      analogWrite(9, turnSpeed);
      analogWrite(3, turnSpeed);
      if (lastTurn == 1) {
        digitalWrite(8, HIGH); digitalWrite(7, LOW);   // Left forward
        digitalWrite(5, LOW);  digitalWrite(4, HIGH);  // Right backward
      } else {
        digitalWrite(8, LOW);  digitalWrite(7, HIGH);  // Left backward
        digitalWrite(5, HIGH); digitalWrite(4, LOW);   // Right forward
      }
    }

    // Phase 3 (900-1800ms): spin opposite direction
    else if (lost < 1800)
    {
      analogWrite(9, turnSpeed);
      analogWrite(3, turnSpeed);
      if (lastTurn == 1) {
        digitalWrite(8, LOW);  digitalWrite(7, HIGH);
        digitalWrite(5, HIGH); digitalWrite(4, LOW);
      } else {
        digitalWrite(8, HIGH); digitalWrite(7, LOW);
        digitalWrite(5, LOW);  digitalWrite(4, HIGH);
      }
    }

    // Phase 4 (1800ms+): STOP - truly lost, wait for manual help
    else
    {
      analogWrite(9, 0);
      analogWrite(3, 0);
      digitalWrite(8, LOW); digitalWrite(7, LOW);
      digitalWrite(5, LOW); digitalWrite(4, LOW);
      // Reset after 2 seconds to try again
      if (lost > 3800) lostTime = 0;
    }
  }
}
```

---

## What Was Wrong & What Was Added
```
PROBLEM                        FIX
──────────────────────────────────────────────────────
No lostTime tracking         → Added lostTime + lastTurn variables
Spun forever when lost       → Replaced with 4-phase recovery
Never stopped spinning       → Phase 4 now fully stops motors
No memory of last direction  → lastTurn saved on every correction
No dash gap handling         → Phase 1 coasts 300ms first
